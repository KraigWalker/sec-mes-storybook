{"version":3,"sources":["features/messages/messagesApi.js","features/queryBuilders/dynamicBaseQuery.js","features/accounts/accountsApi.js","features/routes/AppRouter/AppRouter.jsx","features/session/sessionSlice.js","features/config/configSlice.js","App.js","features/auth/getAuthTokenFromLocationHash.js","features/auth/getAppIdFromBankId.js","features/auth/buildClientContextHeader.js","features/auth/oAuthApi.js","features/auth/getAuthTokenFromCookie.js","features/auth/getAuthToken.js","features/auth/authSlice.js","app/store.js","index.js"],"names":["messagesApi","createApi","reducerPath","baseQuery","dynamicBaseQuery","tagTypes","endpoints","builder","getMessages","query","transformResponse","response","secure_messages","useGetMessagesQuery","rawBaseQuery","fetchBaseQuery","baseUrl","prepareHeaders","headers","token","getState","auth","set","args","api","extraOptions","a","baseApiUrl","config","bankId","session","error","status","data","urlEnd","url","adjustedUrl","adjustedArgs","accountsApi","getAccounts","accounts","useGetAccountsQuery","SECURE_MESSAGES","LETTERS_AND_DOCUMENTS","EmptyComponent","SecureMessagesRoutes","loadable","then","module","LettersAndDocumentsRoutes","DigitalStatementsRoutes","AppRouter","fallback","from","to","path","component","exact","devDefaults","sessionSlice","createSlice","name","initialState","reducers","getSessionDetails","state","action","parse","window","location","search","hash","user_tracking_id","userTrackingId","bank_id","brandId","brand_id","client_context","clientContext","isDocumentLibraryEnabled","exchangeToken","clearQueryString","clearHash","extraReducers","actions","reducer","fetchConfig","createAsyncThunk","console","log","origin","fetch","json","appStartup","dispatch","Promise","all","resolve","configSlice","fulfilled","payload","paasBaseApiUrl","getConfig","updateConfig","clearConfig","createSelector","App","isSMEUser","useDispatch","useEffect","hideLettersAndDocuments","getAuthTokenFromLocationHash","_arg","rejectWithValue","getAppIdFromBankId","appTitle","toUpperCase","WEB","buildClientContextHeader","JSON","stringify","client","app_title","app_package_name","app_version_code","navigator","appVersion","app_version_name","appName","env","platform","platform_version","vendor","opera","make","locale","language","authProviderOAuth2Path","USER","oAuthApi","build","getExchangeToken","shortExchangeToken","method","Authorization","body","getPublicKey","getAuthTokenFromCookie","fulfillWithValue","initiate","publicKey","public_key","finalPublicKey","jwtToken","get","finalJwt","trim","jwt","decodedJWT","verify","algorithms","message","stack","getAuthToken","accessToken","publicToken","rejected","store","configureStore","middleware","getDefaultMiddleware","concat","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e8b04c0d.chunk.js","sourcesContent":["import { createApi } from '@reduxjs/toolkit/query/react';\nimport { dynamicBaseQuery } from '../queryBuilders/dynamicBaseQuery';\n// import { messagesAdapter } from './messagesAdapter';\n\nexport const messagesApi = createApi({\n  reducerPath: 'messages',\n  baseQuery: dynamicBaseQuery,\n  tagTypes: ['Message'],\n  endpoints: (builder) => ({\n    getMessages: builder.query({\n      query: () => `securemessages`,\n      transformResponse(response) {\n        /** @todo should we be adding this to a more uniform entity store? */\n        return response.secure_messages || [];\n      },\n    }),\n  }),\n});\n\nexport const { useGetMessagesQuery } = messagesApi;\n","import { fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: '',\n  prepareHeaders: (headers, { getState }) => {\n    const token = getState().auth.token;\n\n    if (token) {\n      headers.set('authentication', `Bearer ${token}`);\n    }\n\n    headers.set('apiVersion', '1.2.0');\n\n    return headers;\n  },\n});\n\nexport async function dynamicBaseQuery(args, api, extraOptions) {\n  const {\n    config: { baseApiUrl },\n    session: { bankId },\n  } = api.getState();\n\n  // gracefully handle scenarios where data to generate the URL is missing\n  if (!baseApiUrl) {\n    return {\n      error: {\n        status: 400,\n        data: 'No `baseApiUrl` received from config.',\n      },\n    };\n  } else if (!bankId) {\n    return {\n      error: {\n        status: 400,\n        data: 'No `bankId` received from session parameters.',\n      },\n    };\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url;\n  // construct a dynamically generated potion of the url\n  const adjustedUrl = `${baseApiUrl}/banks/${bankId}/${urlEnd}`;\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl };\n  // provide the amended url and other params to the raw base query\n  return rawBaseQuery(adjustedArgs, api, extraOptions);\n}\n","import { createApi } from '@reduxjs/toolkit/query/react';\nimport { dynamicBaseQuery } from '../queryBuilders/dynamicBaseQuery';\n// import { accountsAdapter } from './accountsAdapter';\n\nexport const accountsApi = createApi({\n  reducerPath: 'accounts',\n  baseQuery: dynamicBaseQuery,\n  tagTypes: ['Account'],\n  endpoints: (builder) => ({\n    getAccounts: builder.query({\n      query: () => `accounts/default`, // the query path added to the basePath built by `dynamicBaseQuery`\n      transformResponse(response) {\n        /** @todo should we be adding this to a more uniform entity store? */\n        return response.accounts || [];\n      },\n    }),\n  }),\n});\n\nexport const { useGetAccountsQuery } = accountsApi;\n","import { Suspense } from 'react';\nimport { Switch, Route, Redirect } from 'react-router-dom';\nimport loadable from '@loadable/component';\n\nconst BASE = '/';\nconst OLD_SECURE_MESSAGES_PATH = '/securemessages';\nconst OLD_LETTERS_AND_DOCUMENTS_PATH = '/my-documents';\nconst SECURE_MESSAGES = '/secure-messages';\nconst LETTERS_AND_DOCUMENTS = '/documents';\nconst DIGITAL_STATEMENTS = '/digital-statements';\n\nfunction EmptyComponent() {\n  return null;\n}\n\nconst SecureMessagesRoutes = loadable(() =>\n  import('./SecureMessagesRoutes').then((module) => module.SecureMessagesRoutes)\n);\n\nconst LettersAndDocumentsRoutes = loadable(() =>\n  import('./LettersAndDocumentsRoutes').then(\n    (module) => module.LettersAndDocumentsRoutes\n  )\n);\nconst DigitalStatementsRoutes = loadable(() =>\n  import('./DigitalStatementsRoutes').then(\n    (module) => module.DigitalStatementsRoutes\n  )\n);\n\nfunction AppRouter() {\n  return (\n    <Suspense fallback={EmptyComponent}>\n      <Switch>\n        <Redirect from={OLD_SECURE_MESSAGES_PATH} to={SECURE_MESSAGES} />\n        <Redirect\n          from={OLD_LETTERS_AND_DOCUMENTS_PATH}\n          to={LETTERS_AND_DOCUMENTS}\n        />\n        {/** @todo We actually wanna create a SecureMessagesAppLayout that provides handles `/secure-messages/*` */}\n        <Route path={SECURE_MESSAGES} component={SecureMessagesRoutes} />\n        <Route\n          path={LETTERS_AND_DOCUMENTS}\n          component={LettersAndDocumentsRoutes}\n        />\n        <Route path={DIGITAL_STATEMENTS} component={DigitalStatementsRoutes} />\n        <Redirect exact from={BASE} to={SECURE_MESSAGES} />\n      </Switch>\n    </Suspense>\n  );\n}\n\nexport { AppRouter };\n","import { createSlice } from '@reduxjs/toolkit';\nimport { parse } from 'query-string';\n\n/**\n * It's a hassle to plug query params into local dev, so use some sensible defaults\n */\nconst devDefaults =\n  process.env.NODE_ENV !== 'production'\n    ? {\n        bankId: 'cb',\n      }\n    : {};\n\nif (process.env.NODE_ENV !== 'production') {\n  console.warn('process.env.NODE_ENV !== \"production\".');\n  console.warn('Enabling developer fallback session values.');\n}\n\nconst sessionSlice = createSlice({\n  name: 'session',\n  initialState: {\n    /*userTrackingId: null,\n    bankId: null,\n    brandId: null,\n    state: null,\n    clientContext: null,\n    isDocumentLibraryEnabled: null,\n    exchangeToken: null,\n\t\taccess_token: null <–– deprecated, moved to authSlice */\n  },\n  reducers: {\n    getSessionDetails(state, action) {\n      /**\n       * Parsed session details from the URL query string.\n       */\n      const query = parse(window.location.search);\n      /**\n       * Depending on the competency of the external webapps that link Users to\n       * this app, some of this data may actually be passed\n       * within the url fragment hash (`#`) in a query-string-like format.\n       * An example of this is `exchangeToken`, and (now deprecated) `access_token`.\n       */\n      const hash = parse(window.location.hash);\n\n      return {\n        ...((query.user_tracking_id || hash.user_tracking_id) && {\n          userTrackingId:\n            query.user_tracking_id || hash.user_tracking_id || null,\n        }),\n        ...((query.bank_id ||\n          query.bankId ||\n          hash.bank_id ||\n          hash.bankId ||\n          devDefaults.bankId) && {\n          bankId:\n            query.bank_id ||\n            query.bankId ||\n            hash.bank_id ||\n            hash.bankId ||\n            devDefaults.bankId ||\n            null,\n        }),\n        ...((query.brandId ||\n          query.brand_id ||\n          hash.brandId ||\n          hash.brand_id) && {\n          brandId:\n            query.brandId || query.brand_id || hash.brandId || hash.brand_id,\n        }),\n        ...((query.state || hash.state) && {\n          state: query.state || hash.state,\n        }),\n        ...((query.client_context || hash.client_context) && {\n          clientContext: query.client_context || hash.client_context,\n        }),\n        ...((query.isDocumentLibraryEnabled ||\n          hash.isDocumentLibraryEnabled) && {\n          isDocumentLibraryEnabled:\n            query.isDocumentLibraryEnabled || hash.isDocumentLibraryEnabled,\n        }),\n        ...((query.exchangeToken || hash.exchangeToken) && {\n          exchangeToken: query.exchangeToken || hash.exchangeToken,\n        }),\n      };\n    },\n    /** @todo Implement once comfortable everything works */\n    clearQueryString(state) {\n      return state;\n    },\n    /** @todo Implement once comfortable everything works */\n    clearHash(state) {\n      return state;\n    },\n  },\n  extraReducers: {},\n});\n\n// Extract the action creators object and the reducer\nconst { actions, reducer } = sessionSlice;\n\n// Extract and export each action creator by name\nexport const { getSessionDetails } = actions;\n\n// Export the reducer, as a named export\nexport { reducer as sessionReducer };\n","import {\n  createAsyncThunk,\n  createSlice,\n  createSelector,\n} from '@reduxjs/toolkit';\n//import { getAuthToken } from '../auth/getAuthToken';\nimport { getSessionDetails } from '../session/sessionSlice';\n\nexport const fetchConfig = createAsyncThunk('fetchConfig', async () => {\n  console.log(window.location.origin);\n  const response = await fetch(`${window.location.origin}/config.json`);\n  return response.json();\n});\n\nexport const appStartup = createAsyncThunk(\n  'startup',\n  async (args, { dispatch }) =>\n    Promise.all([\n      await dispatch(fetchConfig()),\n      await dispatch(getSessionDetails()),\n    ]).then(async () =>\n      Promise.all([\n        /** get  */\n        // await dispatch(getAuthToken()),\n      ]).then(() => {\n        Promise.resolve();\n      })\n    )\n);\n\nconst configSlice = createSlice({\n  name: 'config',\n  initialState: { baseApiUrl: null },\n  extraReducers: {\n    [fetchConfig.fulfilled]: (state, action) => {\n      state.baseApiUrl = action.payload.paasBaseApiUrl;\n    },\n  },\n});\n\n// Extract the action creators object and the reducer\nconst { actions, reducer } = configSlice;\n\n// Extract and export each action creator by name\nexport const { getConfig, updateConfig, clearConfig } = actions;\n// Export the reducer, as a named export\nexport { reducer as configReducer };\n\nfunction baseApiUrlSelector(state) {\n  return state.baseApiUrl;\n}\n\nexport const selectBaseApiUrl = createSelector(baseApiUrlSelector);\n","import { useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { AppRouter } from './features/routes/AppRouter';\nimport { appStartup } from './features/config/configSlice';\n\nfunction App({ isSMEUser = false }) {\n  /**\n   * @todo get isSMEUser via redux hook\n   * If the user is an SME User, then there are special restrictions\n   * that may effect them.\n   * Only Business Administrators can view messages for example, so\n   * we'd have to check that.\n   */\n\n  const dispatch = useDispatch();\n\n  useEffect(\n    function startupHook() {\n      dispatch(appStartup());\n    },\n    [dispatch]\n  );\n\n  return <AppRouter hideLettersAndDocuments={isSMEUser} />;\n}\n\nexport { App };\n","import { createAsyncThunk } from '@reduxjs/toolkit';\n\nexport const getAuthTokenFromLocationHash = createAsyncThunk(\n  'auth/getAuthTokenFromLocationHash',\n  (_arg, { rejectWithValue }) => {\n    return rejectWithValue('bar');\n  }\n);\n","/**\n *\n * @param {String} bankId\n * @param {String?} appTitle\n * @returns\n */\nexport function getAppIdFromBankId(bankId, appTitle) {\n  return appTitle || `${bankId.toUpperCase()} Web`;\n}\n","import { getAppIdFromBankId } from './getAppIdFromBankId';\n\nconst WEB = 'WEB';\n\nexport function buildClientContextHeader(bankId, userTrackingId = '') {\n  /**\n   * @todo Some of these values seem excessively verbose and retrograde.\n   * Test to see if we can get rid of some of these through a\n   * process of trial and error.\n   * Or perhaps find an API Spec with information on the Headers required.\n   */\n  return JSON.stringify({\n    client: {\n      user_tracking_id: userTrackingId,\n      app_title: getAppIdFromBankId(bankId),\n      app_package_name: WEB,\n      app_version_code: navigator.appVersion,\n      app_version_name: navigator.appName,\n    },\n    env: {\n      platform: WEB,\n      platform_version:\n        navigator.appVersion || navigator.vendor || window.opera,\n      make: navigator.platform || window.opera,\n      locale: navigator.language,\n    },\n  });\n}\n","import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/dist/query';\nimport { buildClientContextHeader } from './buildClientContextHeader';\n\n/**\n  \"createOAuthJWTTokenPath\": \"/banks/:bankId/auth/provider/oauth2/token/jwt\",\n  \"exchangeOAuthJWTTokenPath\": \"/banks/:bankId/auth/provider/oauth2/token/exchange/jwt\",\n  \"shortTermAccessTokenPath\": \"/banks/:bankId/auth/provider/oauth2/token/shortterm\",\n  \"getPublicKeyPath\": \"/banks/auth/provider/oauth2/jwt/publickey\"\n */\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: '/',\n});\n\nconst dynamicBaseQuery = async (args, api, extraOptions) => {\n  const {\n    config: { baseApiUrl },\n  } = api.getState();\n\n  // gracefully handle scenarios where data to generate the URL is missing\n  if (!baseApiUrl) {\n    return {\n      error: {\n        status: 400,\n        data: 'No base API URL recieved',\n      },\n    };\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url;\n\n  // construct a dynamically generated potion of the url\n  const adjustedUrl = `${baseApiUrl}/banks/${urlEnd}`;\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl };\n  // provide the amended url and other params to the raw base query\n  return rawBaseQuery(adjustedArgs, api, extraOptions);\n};\n\nconst authProviderOAuth2Path = 'auth/provider/oauth2/';\nconst USER = 'USER';\n\nexport const oAuthApi = createApi({\n  reducerPath: 'oAuth',\n  baseQuery: dynamicBaseQuery,\n  endpoints: (build) => ({\n    getExchangeToken: build.query({\n      query: ({\n        shortExchangeToken = 'fakeShortToken' /** @todo get from state.session.exchangeToken instead */,\n        bankId,\n      }) => ({\n        url: `${bankId}/${authProviderOAuth2Path}token/exchange/jwt`,\n        method: 'POST',\n        headers: {\n          'content-type': 'application/x-www-form-urlencoded',\n          Authorization: `Bearer ${shortExchangeToken}`,\n          /** @todo generalize these by adding to dynamicBaseQuery */\n          'x-bpi-client-context': buildClientContextHeader(bankId),\n          'x-bpi-service-context': USER,\n          'X-TS-AJAX-Request': true,\n        },\n        body: 'grant_type=client_credentials&scope=30',\n      }),\n    }),\n\n    /// oauthService.getPublicKey(\n    // paasApiUrl,\n    // bank_id.toUpperCase(),\n    // user_tracking_id\n    //);\n\n    getPublicKey: build.query({\n      query: ({ bankId }) => ({\n        url: `${authProviderOAuth2Path}jwt/publickey`,\n        headers: {\n          /** @todo generalize these by adding to dynamicBaseQuery */\n          'x-bpi-client-context': buildClientContextHeader(bankId),\n          'x-bpi-service-context': USER,\n          'X-TS-AJAX-Request': true,\n        },\n      }),\n    }),\n  }),\n});\n\nexport const {\n  endpoints: { getExchangeToken, getPublicKey },\n} = oAuthApi;\n","import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { getExchangeToken, getPublicKey } from './oAuthApi';\n\nexport const getAuthTokenFromCookie = createAsyncThunk(\n  'auth/getAuthTokenFromCookie',\n  async (args, { dispatch, getState, rejectWithValue, fulfillWithValue }) => {\n    //let jwtToken;\n\n    const {\n      session: { exchangeToken, bankId },\n    } = getState();\n\n    let finalPublicKey;\n    let finalJwt;\n\n    if (bankId) {\n      // Integrate the public key API\n      const {\n        data: { public_key: publicKey },\n      } = await dispatch(getPublicKey.initiate({ bankId }));\n\n      finalPublicKey = publicKey;\n    }\n\n    /**\n     * Check if `exchangeToken` was parsed from `window.location.hash`.\n     * This indicates a \"mobile-to-web\" User Session.\n     * @todo rename mentions of 'exchangeToken' to 'shortTermToken' to reduce confusion\n     */\n    if (exchangeToken && bankId) {\n      // Integrate the exchange token API based on short term token\n      const jwtToken = await dispatch(\n        getExchangeToken.initiate({ exchangeToken, bankId })\n      );\n\n      if (!jwtToken.error) {\n        return jwtToken.data;\n      }\n\n      return jwtToken;\n      // jwtToken = await getExchangeToken(\n      //  bank_id,\n      //  user_tracking_id,\n      //  paasApiUrl,\n      //  shortTermToken\n      // );\n    } else {\n      const { get } = await import('js-cookie');\n\n      const jwtToken = get('ibjwt');\n\n      if (!jwtToken) {\n        return rejectWithValue('could not retrieve a value from Cookie');\n      } else {\n        finalJwt = jwtToken.trim();\n      }\n    }\n\n    // Integrate the verify token method\n    // return getDecodedJWTToken(jwtToken, publicKey);\n\n    //const decodedAuthToken = validateAuthToken(jwtToken, publicKey);\n    //return !decodedAuthToken.error ? decodedAuthToken.jti : null;\n    // Public key needs to be in PEM format for the jsonwebtoken lib so this is why we have the following\n    if (process.env.NODE_ENV === 'production') {\n      // only try and work with a real token in production mode (for now)\n      const jwt = await import('jsonwebtoken');\n\n      try {\n        const decodedJWT = jwt.verify(\n          finalJwt,\n          `-----BEGIN PUBLIC KEY-----${finalPublicKey}-----END PUBLIC KEY-----`,\n          {\n            algorithms: [\n              'RS256',\n              'HS256',\n              'HS384',\n              'HS512',\n              'RS384',\n              'RS512',\n              'none',\n            ],\n          }\n        );\n        return fulfillWithValue(decodedJWT);\n      } catch ({ name, message, stack }) {\n        return rejectWithValue({\n          name,\n          message,\n          stack,\n        });\n      }\n    } else {\n      // For now in development, bypass all this\n      return fulfillWithValue('thisIsAFakeJWTBecauseWeAreInDevelopmentMode');\n    }\n  }\n);\n","import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { getAuthTokenFromCookie } from './getAuthTokenFromCookie';\nimport { getAuthTokenFromLocationHash } from './getAuthTokenFromLocationHash';\n\nexport const getAuthToken = createAsyncThunk(\n  'auth/getAuthToken',\n  async (_arg, { dispatch, rejectWithValue }) => {\n    const { payload, error } = await dispatch(getAuthTokenFromCookie());\n\n    if (error) {\n      const { payload, error } = await dispatch(getAuthTokenFromLocationHash());\n      return error ? rejectWithValue() : payload;\n    }\n    return payload;\n  }\n);\n","import { createSlice } from '@reduxjs/toolkit';\nimport { getAuthTokenFromLocationHash } from './getAuthTokenFromLocationHash';\nimport { getAuthToken } from './getAuthToken';\n// import { getAuthTokenFromCookie } from './getAuthTokenFromCookie';\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState: {\n    accessToken: null,\n    publicToken: null,\n  },\n  reducers: {\n    //   getAuthTokenFromCookie,\n  },\n  extraReducers: {\n    // [getAuthTokenFromCookie.fulfilled]: (state, action) => {\n    //   state.accessToken = action.payload;\n    // },\n    [getAuthTokenFromLocationHash.fulfilled]: (state, action) => {\n      state.accessToken = action.payload;\n    },\n    [getAuthToken.rejected]: (state, action) => {},\n    [getAuthToken.fulfilled]: (state, action) => {\n      state.accessToken = action.payload;\n    },\n  },\n});\n\n// Extract the action creators object and the reducer\nconst { /* actions,*/ reducer } = authSlice;\n\n// Extract and export each action creator by name\n//export const {   } = actions;\n\n// Export the reducer, as a named export\nexport { reducer as authReducer };\n","import { configureStore } from '@reduxjs/toolkit';\nimport { authReducer as auth } from '../features/auth/authSlice';\nimport { oAuthApi } from '../features/auth/oAuthApi';\nimport { configReducer as config } from '../features/config/configSlice';\n// import { messagesReducer as messages } from '../features/messages/messagesSlice';\nimport { messagesApi } from '../features/messages/messagesApi';\nimport { accountsApi } from '../features/accounts/accountsApi';\nimport { sessionReducer as session } from '../features/session/sessionSlice';\n\n/**\n * The central Redux store used throughout the app, combining multiple \"feature\"\n * slices into a single collection.\n */\nexport const store = configureStore({\n  reducer: {\n    auth,\n    config,\n    [accountsApi.reducerPath]: accountsApi.reducer,\n    [messagesApi.reducerPath]: messagesApi.reducer,\n    [oAuthApi.reducerPath]: oAuthApi.reducer,\n    session,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(\n      accountsApi.middleware,\n      messagesApi.middleware,\n      oAuthApi.middleware\n    ),\n});\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport { Provider } from 'react-redux';\nimport { App } from './App';\nimport { store } from './app/store';\nimport './index.css';\n\nfunction prepare() {\n  if (process.env.NODE_ENV !== 'production') {\n    const { worker } = require('./mocks/browser');\n\n    return worker.start({\n      /**\n       * Don't warn the developer about every request that goes unhandled by\n       * mock-service-worker (msw) in development mode.\n       * This reduces the `console.warn()` spam for legitimate static asset requests\n       * or dynamic `import()`s that shouldn't be mocked by msw.\n       * If you find a mocked api response isn't working as you expected,\n       * change this back to `'warn'` to help you debug the issue.\n       */\n      onUnhandledRequest: 'bypass',\n    });\n  }\n  return Promise.resolve();\n}\n\n/**\n * The App is wrapped in all the relevant Router, Theme, and Redux Providers\n * at this level to allow the UI code to be more testable and portable in the\n * future.\n */\nfunction startApp() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <BrowserRouter>\n        <Provider store={store}>\n          <App />\n        </Provider>\n      </BrowserRouter>\n    </React.StrictMode>,\n    document.getElementById('root')\n  );\n}\n\nprepare()\n  .then(() => {\n    /**\n     * If in development mode and @todo process.env.REACT_APP_MOCK_JWT_COOKIE\n     */\n    //if (process.env.NODE_ENV !== 'production') {\n    //  return fetch('https://localhost:8888/mock-jwt-token');\n    //}\n  })\n  .then(() => startApp());\n"],"sourceRoot":""}